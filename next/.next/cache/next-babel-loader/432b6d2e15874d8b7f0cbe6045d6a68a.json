{"ast":null,"code":"import React from \"react\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport App from \"../../components/page\";\nimport path from \"path\";\nimport fs from \"fs\";\nimport LiveEditor from \"../../components/liveEditor\";\nimport ReactMarkdown from \"react-markdown\";\nimport styled from \"styled-components\";\nimport { transformContent, pulckHtmlCss } from \"../../lib/transform\";\n\nconst fetchSections = () => {\n  const postsDirectory = path.join(process.cwd(), \"contents\");\n  const sectionDirectories = fs.readdirSync(postsDirectory);\n  return sectionDirectories.map(section => {\n    const filenames = fs.readdirSync(path.join(postsDirectory, section));\n    return {\n      title: section,\n      items: filenames.map(name => ({\n        title: name,\n        path: `${section}.${name}`\n      }))\n    };\n  });\n};\n\nconst loadContent = filename => {\n  const filePath = path.join(process.cwd(), \"contents\", filename);\n  const fileContents = fs.readFileSync(path.join(filePath), \"utf8\");\n  const content = transformContent(fileContents);\n  return content;\n};\n\nexport async function getStaticPaths() {\n  const contents = fetchSections().map(section => section.items.map(item => ({\n    params: {\n      page: item.path\n    }\n  }))); // flatten\n\n  const paths = Array.prototype.concat.apply([], contents);\n  return {\n    paths,\n    fallback: false\n  };\n}\nexport async function getStaticProps({\n  params\n}) {\n  // HACK section1.demoみたいになっているのでsection1/demoにする\n  const path = params.page.replace(\".\", \"/\");\n  const props = {\n    post: {\n      contents: loadContent(path)\n    },\n    sections: fetchSections()\n  };\n  return {\n    props\n  };\n}\n\nconst _MDWapper = styled.div.withConfig({\n  displayName: \"page___MDWapper\",\n  componentId: \"mxv6kk-0\"\n})([\"h1,h2,h3,h4{color:var(--theme-color);}\"]);\n\nconst MarkdownBlock = ({\n  content\n}) => __jsx(_MDWapper, null, __jsx(ReactMarkdown, {\n  source: content\n})); // これでlinkを外から入れらるようになった。\n// mdからメニューを取得してページングできるはず。\n// ぱすぱらむを取得すれば（static prposで)\n\n\nconst createProps = sections => ({\n  LinkComponent: item => {\n    return __jsx(\"span\", null, __jsx(\"a\", {\n      href: item.item.path\n    }, item.item.title));\n  },\n  sections\n});\n\nconst Page = ({\n  post,\n  sections\n}) => {\n  var _post$contents$find;\n\n  const menuProps = createProps(sections);\n  const commonCSS = pulckHtmlCss(((_post$contents$find = post.contents.find(c => c.type === \"common-css\")) === null || _post$contents$find === void 0 ? void 0 : _post$contents$find.value) || \"\").css;\n\n  const Content = () => __jsx(\"div\", {\n    style: {\n      padding: \"40px\"\n    }\n  }, post.contents.map((content, i) => {\n    const key = `${content.type}-${i}`;\n\n    if (content.type === \"markdown\" || content.type === \"common-css\") {\n      return __jsx(MarkdownBlock, {\n        key: key,\n        content: content.value\n      });\n    }\n\n    if (content.type === \"frontmatter\") {\n      return __jsx(_MDWapper, {\n        key: key\n      }, __jsx(\"h1\", null, content.value.title));\n    }\n\n    return __jsx(LiveEditor, _extends({\n      key: key\n    }, _objectSpread({\n      commonCSS\n    }, content.value)));\n  }));\n\n  return __jsx(App, {\n    content: __jsx(Content, null),\n    menu: menuProps\n  });\n};\n\nexport default Page;","map":null,"metadata":{},"sourceType":"module"}